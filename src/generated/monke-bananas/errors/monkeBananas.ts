/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  isProgramError,
  type Address,
  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,
  type SolanaError,
} from '@solana/kit';
import { MONKE_BANANAS_PROGRAM_ADDRESS } from '../programs';

/** Unauthorized: Not authorized */
export const MONKE_BANANAS_ERROR__UNAUTHORIZED = 0x1770; // 6000
/** Paused: Program is paused */
export const MONKE_BANANAS_ERROR__PAUSED = 0x1771; // 6001
/** NoMonkes: No monkes exist (total share weight is 0) */
export const MONKE_BANANAS_ERROR__NO_MONKES = 0x1772; // 6002
/** NothingToDeposit: Nothing to deposit (dist_pool below minimum) */
export const MONKE_BANANAS_ERROR__NOTHING_TO_DEPOSIT = 0x1773; // 6003
/** NothingToClaim: Nothing to claim */
export const MONKE_BANANAS_ERROR__NOTHING_TO_CLAIM = 0x1774; // 6004
/** NotNftHolder: Caller does not hold the NFT */
export const MONKE_BANANAS_ERROR__NOT_NFT_HOLDER = 0x1775; // 6005
/** InvalidNftMint: Invalid NFT mint */
export const MONKE_BANANAS_ERROR__INVALID_NFT_MINT = 0x1776; // 6006
/** InvalidMint: Invalid token mint */
export const MONKE_BANANAS_ERROR__INVALID_MINT = 0x1777; // 6007
/** NotTokenOwner: Not the token owner */
export const MONKE_BANANAS_ERROR__NOT_TOKEN_OWNER = 0x1778; // 6008
/** InvalidCollection: NFT is not from the SMB Gen2 or Gen3 collection */
export const MONKE_BANANAS_ERROR__INVALID_COLLECTION = 0x1779; // 6009
/** CollectionNotVerified: NFT collection is not verified */
export const MONKE_BANANAS_ERROR__COLLECTION_NOT_VERIFIED = 0x177a; // 6010
/** InvalidMetadata: Invalid metadata account */
export const MONKE_BANANAS_ERROR__INVALID_METADATA = 0x177b; // 6011
/** Overflow: Arithmetic overflow */
export const MONKE_BANANAS_ERROR__OVERFLOW = 0x177c; // 6012
/** NoPendingAuthority: No pending authority */
export const MONKE_BANANAS_ERROR__NO_PENDING_AUTHORITY = 0x177d; // 6013
/** InsufficientVaultBalance: Insufficient SOL in program vault — wait for next deposit_sol */
export const MONKE_BANANAS_ERROR__INSUFFICIENT_VAULT_BALANCE = 0x177e; // 6014
/** NftNotBurned: NFT has not been burned (supply must be 0) */
export const MONKE_BANANAS_ERROR__NFT_NOT_BURNED = 0x177f; // 6015

export type MonkeBananasError =
  | typeof MONKE_BANANAS_ERROR__COLLECTION_NOT_VERIFIED
  | typeof MONKE_BANANAS_ERROR__INSUFFICIENT_VAULT_BALANCE
  | typeof MONKE_BANANAS_ERROR__INVALID_COLLECTION
  | typeof MONKE_BANANAS_ERROR__INVALID_METADATA
  | typeof MONKE_BANANAS_ERROR__INVALID_MINT
  | typeof MONKE_BANANAS_ERROR__INVALID_NFT_MINT
  | typeof MONKE_BANANAS_ERROR__NFT_NOT_BURNED
  | typeof MONKE_BANANAS_ERROR__NO_MONKES
  | typeof MONKE_BANANAS_ERROR__NO_PENDING_AUTHORITY
  | typeof MONKE_BANANAS_ERROR__NOTHING_TO_CLAIM
  | typeof MONKE_BANANAS_ERROR__NOTHING_TO_DEPOSIT
  | typeof MONKE_BANANAS_ERROR__NOT_NFT_HOLDER
  | typeof MONKE_BANANAS_ERROR__NOT_TOKEN_OWNER
  | typeof MONKE_BANANAS_ERROR__OVERFLOW
  | typeof MONKE_BANANAS_ERROR__PAUSED
  | typeof MONKE_BANANAS_ERROR__UNAUTHORIZED;

let monkeBananasErrorMessages: Record<MonkeBananasError, string> | undefined;
if (process.env.NODE_ENV !== 'production') {
  monkeBananasErrorMessages = {
    [MONKE_BANANAS_ERROR__COLLECTION_NOT_VERIFIED]: `NFT collection is not verified`,
    [MONKE_BANANAS_ERROR__INSUFFICIENT_VAULT_BALANCE]: `Insufficient SOL in program vault — wait for next deposit_sol`,
    [MONKE_BANANAS_ERROR__INVALID_COLLECTION]: `NFT is not from the SMB Gen2 or Gen3 collection`,
    [MONKE_BANANAS_ERROR__INVALID_METADATA]: `Invalid metadata account`,
    [MONKE_BANANAS_ERROR__INVALID_MINT]: `Invalid token mint`,
    [MONKE_BANANAS_ERROR__INVALID_NFT_MINT]: `Invalid NFT mint`,
    [MONKE_BANANAS_ERROR__NFT_NOT_BURNED]: `NFT has not been burned (supply must be 0)`,
    [MONKE_BANANAS_ERROR__NO_MONKES]: `No monkes exist (total share weight is 0)`,
    [MONKE_BANANAS_ERROR__NO_PENDING_AUTHORITY]: `No pending authority`,
    [MONKE_BANANAS_ERROR__NOTHING_TO_CLAIM]: `Nothing to claim`,
    [MONKE_BANANAS_ERROR__NOTHING_TO_DEPOSIT]: `Nothing to deposit (dist_pool below minimum)`,
    [MONKE_BANANAS_ERROR__NOT_NFT_HOLDER]: `Caller does not hold the NFT`,
    [MONKE_BANANAS_ERROR__NOT_TOKEN_OWNER]: `Not the token owner`,
    [MONKE_BANANAS_ERROR__OVERFLOW]: `Arithmetic overflow`,
    [MONKE_BANANAS_ERROR__PAUSED]: `Program is paused`,
    [MONKE_BANANAS_ERROR__UNAUTHORIZED]: `Not authorized`,
  };
}

export function getMonkeBananasErrorMessage(code: MonkeBananasError): string {
  if (process.env.NODE_ENV !== 'production') {
    return (monkeBananasErrorMessages as Record<MonkeBananasError, string>)[
      code
    ];
  }

  return 'Error message not available in production bundles.';
}

export function isMonkeBananasError<
  TProgramErrorCode extends MonkeBananasError,
>(
  error: unknown,
  transactionMessage: {
    instructions: Record<number, { programAddress: Address }>;
  },
  code?: TProgramErrorCode
): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &
  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {
  return isProgramError<TProgramErrorCode>(
    error,
    transactionMessage,
    MONKE_BANANAS_PROGRAM_ADDRESS,
    code
  );
}
